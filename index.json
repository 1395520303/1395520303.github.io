[{"content":"","date":"2022年12月01日","permalink":"/","section":"demigodZhang的博客","summary":"","title":"demigodZhang的博客"},{"content":"这里会是我的一些分享💕\n","date":"2022年12月01日","permalink":"/records/","section":"分享","summary":"这里会是我的一些分享💕","title":"分享"},{"content":"这里是我在学习过程中自己的一些理解，可能理解的不是很到位，但是也能提供一些参考吧🙇🏻‍♂️\n","date":"2022年11月28日","permalink":"/articles/","section":"一些文章","summary":"这里是我在学习过程中自己的一些理解，可能理解的不是很到位，但是也能提供一些参考吧🙇🏻‍♂️","title":"一些文章"},{"content":"Controllers #\rcontroller 用来处理请求并返回响应\n我们可以用 CLI 提供的快捷命令nest g co name(name 是控制器的名字)生成一个 controller 看一下，这里我们用nest g co coffees生成一个关于咖啡的控制器 Tips 你可以在生成控制器时带上\u0026ndash;no-spec 参数取消生成测试文件\rimport { Controller } from '@nestjs/common';\r@Controller('coffees')\rexport class CoffeesController {}\r控制器用@Controller 修饰符包裹，可以看到括号中带有‘coffees’的参数。这意味着当我们发起的请求为 http://localhost:3000/coffees 时(nest 默认的请求地址为 localhost 的 3000 端口)这个控制器就可以捕获到。 我们来写一个 get 请求测试一下\nimport { Controller, Get } from '@nestjs/common';\r@Controller('coffees')\rexport class CoffeesController {\r@Get\rfindAll(){\rreturn \u0026quot;this function returns all coffees\u0026quot;\r}\r}\rTips 不要忘记从@nestjs/common 中导入 Get\r我们使用yarn start启动 nest，我使用的是 Apifox，你可以使用其他的工具来发起请求\n我们可以看到，服务器返回了我们想要的结果\n让我们来看看之前的代码是什么意思 @Get 修饰符代表我们处理的请求为 get 方法。 那么如果我们想要处理 post 请求就是用@Post 咯 @Get 下面紧接的就是我们想要处理请求返回结果的方法，方法的名字最好具有解释意义，比如这里我们就用了一个叫做 findAll 的方法用来返回所有的 coffees\n下面我们来介绍 nest 为我们提供的提取参数的方法,下面我会介绍@Param 和 @Body,其他的可以参考Nest-Controllers官方文档\nimport { Body, Controller, Get, Param, Post } from '@nestjs/common';\r@Controller('coffees')\rexport class CoffeesController {\r@Get()\rfindAll() {\rreturn 'this function returns all coffees';\r}\r@Get(\u0026quot;:id\u0026quot;)\rfindOne(@Param(\u0026quot;id\u0026quot;) id:string):string{\rreturn `this function returns id: ${id} coffee`\r}\r@Post()\rcreate(@Body() body):object{\rreturn body\r}\r}\rTips 不要忘记从@nestjs/common 中导入相应的方法\r先来看看@Param 修饰符吧，我们可以看到这一次的@Get 修饰符后携带了参数，并且这个参数是以 : 开头的，熟悉网络请求的小伙伴应该不陌生，这个就是 params 参数啊。这样我们就可以在请求的地址后携带我们想要传递的 params 参数，这里我们传入了一个 id 参数，那么当我们的请求为 localhost:3000/coffees/3 的时候，我们会的 parmas 参数应该是这样的：\n{\r\u0026quot;id\u0026quot;: \u0026quot;2323\u0026quot;\r}\r当我们传递多个 params 参数时，我们也可以在 @Param 修饰符里携带参数提取我们想要的参数，这里我们就提取了这个 id 参数并且将它命名为 id ，这样我们在返回响应的时候就可以用它了。\n相同地，@Body 对应的是请求携带的 body 参数，值得注意的是，@Body 修饰符里也可以携带参数哦。如果我们使用@Body(\u0026ldquo;name\u0026rdquo;)可以提取 body 中对应的 name 属性，但是不建议这样做，因为如果我们只访问特定的属性，验证(validation)会跳过其他的属性，这可能会带来一些问题(验证指的是守卫(Guards)和管道(Pipes)的功能,这里暂且不去介绍)\n有时候我们想要去设定返回的状态码，怎么做呢？这时我们就要请出@HttpCode 修饰符了，我们直接在想要改变状态码的请求处加上@HttpCode 即可。 例如我们想将上面的 Get 请求状态码改为 410,就可以这样做\n@HttpCode(410)\r@Get(\u0026quot;:id\u0026quot;)\rfindOne(@Param(\u0026quot;id\u0026quot;) id:string):string{\rreturn `this function returns id: ${id} coffee`\r}\rTips 修饰符写在@Get 的上方还是下方都可以\r那如果觉得状态码太难记了怎么办，我们还可以用 HttpStatus 来定义状态码 是不是很方便呢 😊\nProviders \u0026amp;\u0026amp; Services #\r这里我本来想用services来做标题，因为我想讲的就是services，但是官方把services放进了Providers里，因为Providers也是Nest里一个很基础的概念，所以我这里就写Providers \u0026amp;\u0026amp; Services吧。\nServices主要是负责处理业务逻辑以及连接数据源。所以我们一般在这里写方法，然后在controller里直接调用方法。我们直接先来生成一个service看一下： 我们使用nest g s coffees生成coffees的service\nimport { Injectable } from '@nestjs/common';\r@Injectable()\rexport class CoffeesService {}\r这就是一个基本的service，用了@Injectable修饰符，emm🧐这个就涉及到Provider的概念了，是一个注入依赖的概念，还有管道，守卫等等都会用到这个@Injectable修饰符，官方说这是Angular中的概念，我也没有系统地学过Angular，所以我们就先跳过吧。\n要注入依赖我们需要在之前创建的controller中使用构造函数\n@Controller('coffees')\rexport class CoffeesController {\rconstructor(private readonly coffeeService: CoffeesService) {}\r@Get()\r```\r像是这样，nest就会为我们初始化一个coffeeService的实例或者调用已经存在的实例，我们就可以使用coffeeService里的东西了\n我们为coffees建一个实体类型\ncoffee.entity.ts\nexport class Coffee{\rid:number;\rname:string;\rbrand:string;\rflavors:string[]\r}\r然后我们去coffeeService中写死一些数据并添加一个findAll方法\nimport { Injectable } from '@nestjs/common';\rimport { Coffee } from './entities/coffee.entity';\r@Injectable()\rexport class CoffeesService {\rprivate coffees: Coffee[] = [\r{\rid: 1,\rname: 'Shipwreck Roast',\rbrand: 'buddy Brew',\rflavors: ['chocolate', 'vanilla'],\r},\r];\rfindAll() {\rreturn this.coffees;\r}\r}\r去coffee.Controller里改写之前的findAll方法\n@Get()\rfindAll(): Array\u0026lt;Coffee\u0026gt; {\rreturn this.coffeeService.findAll();\r}\r现在我们重新发起请求，会得到以下的结果 其实也不难，对吧😁\n","date":"2022年11月20日","permalink":"/articles/nestjs/","section":"一些文章","summary":"关于NestJs的一些简单使用","title":"NestJs"},{"content":" 第一次写博客有点不知所措，随便聊聊吧😋 之前跟着学Nestjs的时候视频里用了prisma，当时听的似懂非懂，感觉Nestjs好用又不好用，Nestjs没记住多少但是记住了prisma，所以现在想仔细学一下 本篇文章只是介绍一下prisma连接数据库（我用的是mysql）以及一些简单的操作（复杂的我暂时还用不上），所以如果有讲的不好的请多多见谅🤧\n注意 本教程需要安装Node.js（12.2及以上）\r1.安装Prisma #\r先建立一个文件夹,这里我就建立一个叫做prisma-mysql的文件夹\nmkdir prisma-mysql cd prisma-mysql\r然后我们初始化一下并添加依赖\nnpm init -y\rnpm i prisma -D\r现在我们就可以调用Prisma CLI了，通过前缀npx来调用Prisma CLI:\nnpx prisma\r通过使用以下命令创建Prisma schema文件来设置Prisma项目\nnpx prisma init\r这个Prisma schema是什么呢 咱们使用 npx prisma init 会建立一个名为prisma的新目录，其中包含一个名为schema.prisma的文件和一个位于项目根目录中的.env文件 schema.prisma中包含了prisma模式，简单来说就是连接什么数据库，还有prisma客户端生成器，这个我觉得不用了解，知道就好😁 .env是一个用于定义环境变量的文件（用于数据库连接）。\n2.连接数据库 #\rprisma/schema.prisma #\rdatasource db {\rprovider = \u0026quot;postgresql\u0026quot;\rurl = env(\u0026quot;DATABASE_URL\u0026quot;)\r}\r嗯，这就是你应该在schema.prisma中应该看到的东西🧐，因为prisma默认使用的是postgresql，所以刚刚你用的init命令就建立了postgresql的连接，现在我们把它改成mysql的连接\ndatasource db {\rprovider = \u0026quot;mysql\u0026quot;\rurl = env(\u0026quot;DATABASE_URL\u0026quot;)\r}\r怎么样，是不是还挺简单的\n下面我们设置一下这个DATABASE_URL，如果你已经看过了.env文件，那你应该对这个东西不是很陌生。要连接mysql数据库，这个url的结构应该是这个样子的\nmysql://Username:Password@Host:Port/Database\r本地运行时，你的URL通常是这个样子的\nDATABASE_URL=\u0026quot;mysql://root:randompassword@localhost:3306/mydb\u0026quot;\r3.创建表单 #\r接下来我们建一些表玩一下这个prisma，就用官方给出的例子吧\nprisma/schema.prisma #\rmodel Post {\rid Int @id @default(autoincrement())\rcreatedAt DateTime @default(now())\rupdatedAt DateTime @updatedAt\rtitle String @db.VarChar(255)\rcontent String?\rpublished Boolean @default(false)\rauthor User @relation(fields: [authorId], references: [id])\rauthorId Int\r}\rmodel Profile {\rid Int @id @default(autoincrement())\rbio String?\ruser User @relation(fields: [userId], references: [id])\ruserId Int @unique\r}\rmodel User {\rid Int @id @default(autoincrement())\remail String @unique\rname String?\rposts Post[]\rprofile Profile?\r}\r这些数据模型需要映射到数据库中，我们使用prisma migrateCLI命令\nnpx prisma migrate dev --name init\r这个name你可以自己取，它用于给你这次的记录命名 现在我们的表单也创建好了，下面我们就要往表里添加数据并进行操作了！😋\n4.添加数据并进行操作！ #\r要开始使用Prisma Client，你需要安装@prisma/client包\nnpm install @prisma/client\r安装命令会自动调用prisma generate，它会读取prisma模式并生成一个适合您的模型的prisma Client版本。\n这个generate命令嘛，官方的解释我还不是很懂，不过用我的理解来讲（比较浅显），就是它会根据你在schema.prisma文件里的模型去数据库里生成对应的表，有时间我再去看看吧🤣\n下面我们在根目录中建立一个index.js文件\nindex.js #\rconst { PrismaClient } = require('@prisma/client')\rconst prisma = new PrismaClient()\rasync function main() {\rconst allUsers = await prisma.user.findMany()\rconsole.log(allUsers)\r}\rmain()\r.catch((e) =\u0026gt; {\rthrow e\r})\r.finally(async () =\u0026gt; {\rawait prisma.$disconnect()\r})\r接着我们执行下面的命令\nnode index.js\r结果应该是一个空的数组，很明显，我们没有添加数据嘛\n我们在原有的基础上加上一些代码\nawait prisma.user.create({\rdata: {\rname: 'Alice',\remail: 'alice@prisma.io',\rposts: {\rcreate: { title: 'Hello World' },\r},\rprofile: {\rcreate: { bio: 'I like turtles' },\r},\r},\r})\r这就是添加数据的操作\n完整版： #\rasync function main() {\rawait prisma.user.create({\rdata: {\rname: 'Alice',\remail: 'alice@prisma.io',\rposts: {\rcreate: { title: 'Hello World' },\r},\rprofile: {\rcreate: { bio: 'I like turtles' },\r},\r},\r})\rconst allUsers = await prisma.user.findMany({\rinclude: {\rposts: true,\rprofile: true,\r},\r})\rconsole.dir(allUsers, { depth: null })\r}\r我们看到的结果应该是这样的：\n[\r{\remail: 'alice@prisma.io',\rid: 1,\rname: 'Alice',\rposts: [\r{\rcontent: null,\rcreatedAt: 2020-03-21T16:45:01.246Z,\rid: 1,\rpublished: false,\rtitle: 'Hello World',\rauthorId: 1,\r}\r],\rprofile: {\rbio: 'I like turtles',\rid: 1,\ruserId: 1,\r}\r}\r]\r查看数据库应该也能看到我们添加了相对应的数据\n下面再看看修改的操作\nasync function main() {\rconst post = await prisma.post.update({\rwhere: { id: 1 },\rdata: { published: true },\r})\rconsole.log(post)\r}\r你将看到以下输出\n{\rid: 1,\rtitle: 'Hello World',\rcontent: null,\rpublished: true,\rauthorId: 1\r}\r怎么样，是不是感觉prisma还是挺有意思的😊\n5.在浏览器中查看数据库 #\r当时让我印象最深刻的还是prisma的这个功能，它可以在浏览器中看数据库耶！\n你只要在终端中输入以下命令\nnpx prisma studio\r就可以在浏览器中查看你的数据库，可以在表中进行增删改查的操作，很方便不是吗？\n关于prisma连接mysql的简单操作应用就到这里了，这是我的第一篇博客，第一次写博客感觉花了好多时间，但是我觉得挺开心的，希望以后可以坚持下去，和你们分享学到的东西和我的理解🥳\n","date":"2022年11月20日","permalink":"/articles/prisma-mysql/","section":"一些文章","summary":"使用Prisma连接mysql","title":"使用Prisma连接mysql"},{"content":"","date":"0001年01月01日","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]